{
  "projects": [
    {
      "title": "Color Processor",
      "preview": "assets/Projects/ColorCorrection/thumbnail.jpg",
      "hero": "assets/Projects/ColorCorrection/preview.png",
      "route": "ColorCorrection",
      "softwareUsed": ["WPF", "EMGUCV"],
      "description": [
        "This tool was created to help process an existing fabric and generate PBR textures for it. The VIZIO scanner outputs the files required for the pipeline, but does not do any processing. The main purpose of this tool was to take the output from the scanner and adjust the tone to grayscale and equalize the output, this way we can easily create any color from only the single scanned fabric.",
        "I tried a few different approaches to load and edit the textures, quickly realising GPU based operations would be my best bet. I found EmguCV, which is a .NET wrapper for the C++ OpenCV. I automated the conversion process and made sure to use the correct color algorithms as they are generally understood in Photoshop and other image editors."
      ]
    },
    {
      "title": "Deputy Donut",
      "preview": "assets/Projects/DeputyDonut/thumbnail.jpg",
      "hero": "assets/Projects/DeputyDonut/preview.png",
      "route": "DeputyDonut",
      "softwareUsed": ["Unity", "3DsMax", "Photoshop"],
      "description": [
        "For this project we worked with a team of 5 people (1 artist and 4 programmers) to make a couch co-op game. This game was meant to be made during a single semester, and to be presented at the end.",
        "The purpose of the game was for the police to recover his donuts, because the donut truck ran off without giving him his order! The player is meant to battle the truck with various power ups to try and get the truck to stop and get himself a reward.",
        "I picked up the role of a technical artist. With a team of 4 programmers, we all needed to jump in  to help our artist. Most of my time was spent helping to create the models and rigging, as 3 people is enough to do the programming. In the end it was a fun project and a valuable first group work experience."
      ]
    },
    {
      "title": "Metadata hider",
      "preview": "assets/Projects/MetaHider/thumbnail.jpg",
      "hero": "assets/Projects/MetaHider/preview.jpg",
      "route": "unity-metadata-hider",
      "softwareUsed": ["Unity", "Console"],
      "description": [
        "Because Unity creates a metadata file for every file and directory in the project, this can quickly get cluttered and make it hard to identify objects in the windows explorer. Therefore I wrote a tool that takes these meta files and hides / unhides them.",
        "Windows allows access to the flags controlling various parameters of files, and as such we can modify the properties of said files. As an added bonus I made sure I could watch for file changes in a directory, and not have to manually hide the files when a new one is created."
      ]
    },
    {
      "title": "Media Manager",
      "preview": "assets/Projects/PlexManager/thumbnail.jpg",
      "route": "plextool",
      "softwareUsed": ["WPF"],
      "description": [
        "Unfortunately, this is a program that runs in the background and has no UI. It manages data for me on a server and does not require user interference. Whenever a file is moved as well, both the original location and the destination are logged, to make sure that if a file goes corrupt or missing for any reason I can easily track down what and where the file is to resolve it",
        "Managing a database of assets or files, even on a smaller scale can be quite tedious. When a file is downloaded I needed to manually move the files to a new directory, creating one in the process where required. However, after doing this for a few weeks I realised I could write something to do this for me.",
        "Most of the process happens automatically. Using several API's to check what a file is and where it is supposed to go, I can figure out what goes where and make sure everything is in the right place. Matching a downloaded movie to its IMDB page, makes it possible to correctly identify the movie and as such find possible typos in the file system. I used a fuzzy search to make sure there is a margin for error.",
        "Additionally, this tool uses the FileSystemWatcher to make sure that files get transferred automatically. To move files around I am using a kernel32.dll property to speed up the process of moving the objects around. This is a significant increase in performance compared to the regular file moving operations in C#. With a little added complexity, I was able to speed up and async move files at about 10 times the speed of the regular operation."
      ]
    },
    {
      "title": "Portfolio",
      "preview": "assets/sprites/qr-code.png",
      "hero": "assets/Projects/Website/preview.jpg",
      "route": "portfolio",
      "softwareUsed": ["Angular"],
      "description": [
        "Preliminary research into Vue.js and Angular along with the requirement of working with Angular in a professional environment, I found it a learning experience. Starting to learn javascript, and later typescript coming from C# has its challenges, but it ended up being a fun project nonetheless.",
        "Working with Typescript and the Angular framework was a lot easier as it is a more object oriented approach to Javascript. to me there was no better way to learn the framework than to actually make a website with it.",
        "Additional research into threejs and WebGL rendering in the browser, along with some modelling was quite a nice addition to my portfolio, the result of this is visible on the homepage! Threejs is fully rendered on the front-end, it works in a canvas using the WebGL renderer. On top of that, there was a lot of optimization to be done with the models. Threejs has support for FBX, but the filesizes are a problem on that regard. Using a native binary webGL format I can save a lot on loadtime and make the site load at an acceptable rate!"
      ]
    },
    {
      "title": "Node Editor",
      "preview": "assets/Projects/NodeEditor/thumbnail.png",
      "hero": "assets/Projects/NodeEditor/preview.png",
      "route": "node-editor",
      "softwareUsed": ["Unity", "xNode"],
      "description": [
        "For a project I decided it would be nice to have a node editor. To make one there are different available API's to use, I tried both the Unity experimental Shadergraph API and xNode.",
        "While I was working with the ShaderGraph API, I found myself quite lost, there was not all the much documentation and with the API still being experimental it was bound to be a nuisance to get everything right. I found myself stuck working with USS and UIElements in the UnityEngine, and after running into one too manny roadblocks, I decided to look for an alternative.",
        "The alternative was xNode, an open-source framework that allows you to make a custom node editor the way you want to. I had been following this framework for a while and have to say that it is far more intuitive in its usage than the unity variant. It uses attributes and in turn the unity GUI system for custom editors, which makes it a lot easier to get into and start creating with."
      ]
    },
    {
      "title": "Cubic",
      "preview": "assets/Projects/Cubic/thumbnail.png",
      "hero": "",
      "route": "Cubic",
      "softwareUsed": ["ThreeJS", "GSAP"]
    }
  ]
}
